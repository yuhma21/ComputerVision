=================================
Descriptor
=================================

著者:yuhma21

.. contents:: コンピュータビジョンの導入
   :depth: 2

画像間の対応付けの方法

#. Harrisコーナー検出
#. SIFT

パノラマ画像の作成、拡張現実、3次元復元などに利用される

Harrisコーナー検出器
===============================================

* 周辺に複数の方向のエッジ、コーナーを求める

x方向、y方向の各点の傾きを計算し、下記に定義した式に代入する

.. math::

   M_I = \nabla I \nabla I^{T} = \left[ \begin{pmatrix} I_x^{2} & I_x I_y \\
   I_x I_y & I_y^{2} \end{pmatrix} \right]

   \overline{M_I} = W \times M_I

そして、定義した式にW（ガウス分布）等をかけ、重み行列とする。 :math:`\overline{M_I}` はHarris行列と呼ばれる。
Harris行列の固有値でコーナーを判断する。

**Harris行列の判別方法**

===================  ===================  ============================
:math:`\lambda _1`   :math:`\lambda _1`    判定
===================  ===================  ============================
大きな正の値            大きな正の値             xにコーナーが存在する
大きな値               0に近い値               xにエッジがある
0に近い値              0に近い値               何もない
===================  ===================  ============================

通常は固有値を計算しないで済むように下記の判別関数を使う

.. math::
   
   \frac{det(\overline{M_I})}{trace(\overline{M_I})}

detは行列の判別式、traceは対角成分の和を示す

値が大きい場合はコーナーがあり、中位はエッジで、0に近い箇所は平坦といったところでしょうか。

----

.. function:: gaussian_filter(input, sigma, order=0, output=None, mode='reflect', cval=0.0)
   :module: scipy.ndimage.filters

   多次元のガウシアンフィルタ

   Parameters :

      input : フィルタを×配列を指定する
      
      sigma : 各次元のシグマの値をリストで代入する(x,y,z,......)

      ortder : 出力を行う次元のリストを指定する(1,0,0,...)xだけ出力

      output : フィルタをかけた配列を出力する配列を指定する

      mode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional

      cval : scalar, optional

   Returns :	
      gaussian_filter : ndarray

      インプットと同じ形の配列を返す

----

**ハリスのコーナー検出を行うコード**

.. code-block:: python
   :linenos:

   def compute_harris_response(im, sigma=3):
       """ グレースケール画像の各ピクセルについて
           Harrisコーナー検出器の応答関数を定義する
           im:numpy配列形式の画像
       """
       #微分係数
       imx = np.zeros(im.shape)
       filters.gaussian_filter(im, (sigma, sigma), (0, 1), imx)
       imy = np.zeros(im.shape)
       filters.gaussian_filter(im, (sigma, sigma), (1, 0), imy)
       #Harrisの行列成分を計算する
       Wxx = filters.gaussian_filter(imx * imx, sigma)
       Wxy = filters.gaussian_filter(imx * imy, sigma)
       Wyy = filters.gaussian_filter(imy * imy, sigma)
       #判別式と対角成分
       Wdet = Wxx * Wyy - Wxy ** 2 #判別式
       Wtr = Wxx + Wyy #トレース
   
       return Wdet / Wtr


x,y方向にそれぞれ微分した様子

左側はx方向なので、縦線のコーナーに強く陰影が出ています。

.. image:: /cv/descripter/harrisGauss.png

コーナー検出の様子（左：元画像、右：コーナー）

.. image:: /cv/descripter/harrisC.png

得られたハリスの判別行列からコーナーを検出する。
閾値は割合

.. code-block:: python
   :linenos:

   def get_harris_points(harrisim, min_dist=10, threshold=0.1):
       """ Harris応答画像からコーナーを返す
           min_distはコーナーや画像境界から分離する最小ピクセル数
           (画像のエッジから無視するピクセル数）
       """
       #閾値を超えるコーナー候補を見つける
       corner_threshold = harrisim.max() * threshold
       harrisim_t = (harrisim > corner_threshold) * 1
   
       #候補の座標を取得する
       coords = np.array(harrisim_t.nonzero()).T
       #対象の画像が1出会った座標のx座標群とy座標群を取得
       #転置することによって、(x,y)の組み合わせを作る
   
       #候補の値を取得する
       candidate_values = [harrisim[c[0], c[1]] for c in coords]
   
       #候補をソートする
       index = np.argsort(candidate_values)
   
       #許容する点の座標を配列に格納する
       allowed_locations = np.zeros(harrisim.shape)
       allowed_locations[min_dist:-min_dist,min_dist:-min_dist] = 1
   
       #最小距離を考慮しながら、最良の点を取得する
       filtered_coords = []
       for i in index:
           if allowed_locations[coords[i,0],coords[i,1]] == 1:
               filtered_coords.append(coords[i])
               allowed_locations[(coords[i,0]-min_dist):(coords[i,0]+min_dist),
               (coords[i,1]-min_dist):(coords[i,1]+min_dist)]=0
       return  filtered_coords

まずは閾値でコーナーを検出した時点の画像

.. image:: /cv/descripter/corner.png

コーナーを検出した座標郡は次の通り

[array([760, 543]), array([558, 339]), ...... array([706, 207]), array([789, 214])]

実際に画像に映し出す関数は下記の通り

.. code-block:: python
   :linenos:

   def plot_harris_points(image, filtered_coords):
       """ 画像中に見つかったコーナーを描画
       """
       plt.figure()
       plt.gray()
       plt.imshow(image)
       plt.plot([p[1] for p in filtered_coords],[p[0] for p in filtered_coords], '*')
       plt.axis('off')
       plt.show()

.. image:: /cv/descripter/harrisDe.png

----

.. function:: nonzero(a)
   :module: numpy

   与えられた配列のゼロでない位置を収めたリストを返す

   .. code-block:: python
   
      >>> a = np.array([[1, 1, 1], [1, 0, 0]])
      >>> a
      array([[1, 1, 1],
             [1, 0, 0]])
      >>> b = np.array(a.nonzero())
      >>> b
      array([[0, 0, 0, 1],
             [0, 1, 2, 0]])
      >>> b.T
      array([[0, 0],
             [0, 1],
             [0, 2],
             [1, 0]])

   得られたnonzeroの結果を転置すると行列の組のリストが作れます

----

画像間の対応点を見つける
----------------------------------

コーナーとして検出された点の周辺の（グレースケール）強度をパッチとして1データにする


**パッチの取得**

.. code-block:: python
   :linenos:

   def get_descriptors(image, filtered_coords, wid=5):
       """ 各点について、点の周辺で幅 2*wid+1 の近傍ピクセル値を返す
       """
       desc = []
       for coords in filtered_coords:
           #コーナー周辺の2*wid+1のグレースケール強度をパッチとして保存
           patch = image[coords[0]-wid:coords[0]+wid+1,
                       coords[1]-wid:coords[1]+wid+1].flatten()
           desc.append(patch)
       return desc

出てくるパッチ（局所記述子）は下記の通り

.. code-block:: python

   [array([ 88,  78,  67,  53,  94, 166, 162,  98,  78,  82,  72,  91,  74,
           70, 122, 171, 138,  83,  81,  79,  70, 100, 102,  67, 103, 148,
          115,  79,  90,  83,  82, 115, 167, 109, 113, 136,  91,  80,  93,
           78,  93, 138, 181, 189, 158, 134,  84,  91,  86,  84, 114, 158,
          191, 183, 150, 110,  90, 103,  85,  91, 129, 177, 190, 170, 140,
          104,  88, 103,  93, 103, 150, 191, 189, 162, 123,  99, 120,  96,
           94, 122, 174, 194, 182, 149, 111, 106, 122, 121,  95, 142, 184,
          192, 169, 133, 102, 116, 130, 118, 137, 158, 191, 182, 152, 122,
          100, 123, 129, 120, 151, 190, 186, 178, 140, 106, 108, 134, 121,
          129, 174, 193, 185], dtype=uint8), 
    array([  8,  11,  13,  47, 143, 195, 208, 123, 111,  64,  25,   9,  14,
           21,  45, 144, 195, 216, 132, 112,  71,  28,  14,  21,  28,  44,
          133, 194, 216, 137, 117,  83,  26,  20,  27,  34,  41, 123, 193,
          219, 142, 117,  91,  31,  26,  32,  38,  38, 122, 186, 226, 151,
          113,  97,  28,  33,  38,  42,  48, 127, 173, 224, 160, 113, 103,
           28,  35,  37,  49,  72, 143, 172, 224, 165, 113, 101,  31,  33,
           49,  59, 106, 151, 168, 221, 169, 111, 105,  34,  42,  50,  85,
          124, 150, 164, 221, 176, 113, 105,  40,  41,  63, 115, 128, 144,
          158, 217, 182, 112,  94,  42,  49,  95, 126, 129, 156, 152, 218,
          187, 108, 101,  44], dtype=uint8), ..........
          ..............................................
    array([252, 229, 201, 151,  81,  63,  60,  57,  63, 188, 253, 228, 203,
          138,  74,  58,  59,  50,  46,  65, 197, 252, 201, 139,  72,  57,
           53,  46,  41,  43,  70, 207, 252, 132,  71,  56,  46,  41,  33,
           37,  44,  72, 215, 252,  62,  52,  47,  41,  32,  31,  36,  35,
           68, 220, 251,  51,  47,  40,  30,  32,  27,  29,  34,  66, 220,
          253,  43,  37,  32,  28,  25,  22,  30,  43,  74, 225, 253,  35,
           35,  28,  23,  22,  28,  35,  46,  83, 233, 251,  39,  31,  29,
           23,  25,  34,  38,  49,  93, 237, 250,  40,  36,  31,  21,  27,
           39,  42,  49, 114, 248, 247,  41,  38,  30,  24,  34,  41,  43,
           72, 198, 254, 249], dtype=uint8)]

**パッチの距離を求める**

2つのパッチ間の距離を求める

.. code-block:: python
   :linenos:

   def match_two_pic(desc1, desc2, threshold=0.5):
       """ 正規化相互相関を用いて、第１画像の各コーナー点記述子について
           第２画像の対応点を選択する。
       """
       #各記述子の要素数を取得
       n = len(desc1[0])
       ##対応点ごとの距離##
       #2点間の距離総当り表を作る
       d = -np.ones((len(desc1),len(desc2)))
       for i in range(len(desc1)):
           for j in range(len(desc2)):
               d1 = (desc1[i] - np.mean(desc1[i])) / np.std((desc1[i]))
               d2 = (desc2[j] - np.mean(desc2[j])) / np.std((desc2[j]))
               ncc_value = np.sum(d1 * d2) / (n-1)
               if ncc_value > threshold:
                   d[i,j] = ncc_value
       ndx = np.argsort(-d)
       matchscores = ndx[:,0]
       return matchscores

パッチの距離対応表は下記の通り

.. image:: /cv/descripter/patchDist.png

.. code-block:: python

   [[373 364 330 ..., 123 145 389]
    [304 265 264 ..., 123 145 389]
    [305 233  79 ..., 128 138 389]
    ..., 
    [200  72 143 ..., 123  97 389]
    [ 67 188 363 ..., 128 137 389]
    [151  40 346 ..., 123 145 389]]

   [373 304 305 134 136 111  72 357   7 357 339 277 337 315  15   6 105 256
    297   0 281 283 354 136 351 197 189 375  27 346 342 276 354  67  71 376
    204  43 355 220 370 337 337 140 112  55 277 327 284  69 241 299 349 154
     84 303 323 194 305 322 107  51 172   0 263  17   0 297  36  18 336  53
      0 212 321 189  73 334 261 237 368   0  54 269 272 349 276 354 194 200
    338  17 297  51   0 286 114 365 247 318   0  11  89  37 275   0  28 245
    356 356  84  17   0 337 318 270 364  24 150 345 194 366  46   0 346 136
    223   0 289   0 271 206 372 297   3 255 290 204  42 305 209 349  87 272
    276  11 179 120  90 347 281 159 159 176 221   0 164 222  72 310 360 284
    232   0 290  23 158 234 281 277 263 218 278   0   0 303 279 221 355 264
     21 193 124 206 181 184  21 303   3 120 334   0 365 221 105  46 373   0
      0 360   0 305   0 154  21 360 297 328  13   0  32   0 232 183 179 282
     77  17 159 184  67 261 203  46 194 273 281  13 245 194 305   0 171 105
    205 373 254 206 305   0  21 378 248 181 185 273 269 115 263 159 105 118
    334  61 354 277  73 332  21  13 233  71  50   5   0   0 248   3 321 333
    157 238  69 159 315 353 320 305 297 330 379 306 382  28 305 276 112 349
    349  28  91 364   1 264 305 233 353 299 233   0 198 346 289 239 217 194
    381 151 263 165 359 172 356 305   0 193 198 281 320 328   0   0  13   0
    322 360 214 136 222 337 154 365   0 101 187 199 270  62 235 350 360 273
     13 351  62 279 353 337  37  28 272 296 368  87 244 169 272 281  13 281
    183 354 315 263  93  53 370 281 230 269  95 137 381  87  55  18  46 208
    373 332 188 176 300 179  13 263 367 272 320   0 354 256 102 355  96 330
     49   5 328 118 365 369 223 222 136 349   5 105 356 372 333 297   0 305
    247 217 181 311 187 214   0 107  65 315 372 273   0  13  20   7 181 300
    206 145 305 228 228  67 305 349 146 204 369   0 305 271 304 233 355 327
    159   0 297 151  67  28 204 269 307 264 116 220 359 230 373 276 365 111
    299   3 223   5 206  18 381 372 273 262 300 322 315 187 300 254  52  28
    176 372 347 333 112 164 118 339  70  21   7 276 299 263 207 124   3 329
     69 327 367 344 378 273 209  32   0 194 290 328 310 271 256 233 376 145
     13 330   5 303 328   0   7 349 300 370 150  46  19  86 115 365 269 349
     42 161 183 284  13  67  61 334  39 255 305 204 276  11 146 322 334 333
    177 216 330  11  28  39 200  67 151]   